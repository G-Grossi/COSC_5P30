!SESSION 2023-02-24 14:17:24.242 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-02-24 14:17:24.820
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-02-24 14:17:35.217
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-02-24 14:17:36.073
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-24 14:17:36.073
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-24 14:17:36.073
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-24 14:17:38.054
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2023-02-24 17:20:46.971
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.lookup.Scope.getType(char[])" because "scope" is null
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.getTypeBinding(ArrayTypeReference.java:115)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:522)
	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.internalResolveType(ArrayTypeReference.java:202)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:625)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:621)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:282)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:259)
	at org.eclipse.jdt.internal.codeassist.select.SelectionOnLocalName.resolve(SelectionOnLocalName.java:32)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine$1Visitor.visit(SelectionEngine.java:1470)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:476)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:437)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.selectLocalDeclaration(SelectionEngine.java:1559)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1088)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:124)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3642)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-02-24 17:20:46.995
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.lookup.Scope.getType(char[])" because "scope" is null
	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:60)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:522)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:625)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:621)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:282)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:259)
	at org.eclipse.jdt.internal.codeassist.select.SelectionOnLocalName.resolve(SelectionOnLocalName.java:32)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine$1Visitor.visit(SelectionEngine.java:1470)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:476)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:437)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.selectLocalDeclaration(SelectionEngine.java:1559)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1088)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:124)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4054)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3642)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2023-03-04 08:33:49.554 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-04 08:33:50.128
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-04 08:34:08.519
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-04 08:34:09.474
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-04 08:34:09.474
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-04 08:34:09.474
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-04 08:34:11.136
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-13 18:30:31.104 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-13 18:30:31.649
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-13 18:30:38.879
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-13 18:30:39.794
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-13 18:30:39.794
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-13 18:30:39.794
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-13 18:30:41.420
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:32.119
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = support/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:42:32.120
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:42:32.121
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:32.146
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = support/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:32.147
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:32.147
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:33.954
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = fsupport/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:42:33.954
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:42:33.955
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:33.959
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = fsupport/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:33.959
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:33.959
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:35.465
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = float(support/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:42:35.466
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:42:35.466
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:35.714
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = float(support/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:35.714
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:35.715
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:38.490
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = float(support/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:38.490
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:38.491
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:40.788
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = float(support/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:40.788
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:40.789
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:42.183
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = float(support/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:42.183
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:42.183
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:45.027
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = float(support/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:45.028
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:45.028
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:45.871
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:42:45.872
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:42:45.872
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:46.018
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:46.018
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:46.018
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:50.463
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:50.464
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:50.464
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:51.449
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:42:51.450
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:42:51.450
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:51.539
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:51.539
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:51.540
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:53.047
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if()
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:42:53.047
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:42:53.048
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:53.340
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if()
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:53.341
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:53.341
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:55.567
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(us)
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:42:55.568
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:42:55.568
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:55.690
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(us)
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:55.690
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:55.691
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:56.399
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if()
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:42:56.400
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:42:56.400
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:56.463
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if()
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:56.464
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:56.464
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:42:59.574
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if()
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:42:59.574
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:42:59.574
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:01.920
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if()
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:01.921
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:01.921
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:02.492
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if()
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor59.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:02.493
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor59.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:02.493
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor59.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:04.607
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if()
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:04.608
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:04.608
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:07.208
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport)
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:07.209
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:07.209
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:07.313
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport)
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:07.314
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:07.314
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:08.231
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport )
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:08.232
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:08.232
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:08.296
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport )
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:08.296
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:08.297
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:09.334
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport > 0)
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:09.335
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:09.335
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:09.339
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport > 0)
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:09.339
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:09.339
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:11.716
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport > 0)
	   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:11.717
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:11.717
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:16.567
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:16.568
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:16.568
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:16.662
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:16.662
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:16.662
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:17.284
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:17.284
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:17.285
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:18.438
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:18.439
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:18.439
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:19.502
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:19.503
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:19.503
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:22.808
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:22.808
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:22.809
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:22.866
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:22.867
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:22.867
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:24.023
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:24.024
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:24.024
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:24.032
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:24.033
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:24.033
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:24.679
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:24.680
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:24.680
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:25.224
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:25.225
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:25.225
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:25.290
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:25.290
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:25.291
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:25.294
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:25.294
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:25.295
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:27.355
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:27.356
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:27.356
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:42.492
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:42.493
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:42.493
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:43.844
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:43.844
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:43.845
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:44.855
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:44.856
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:44.856
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:44.903
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:44.904
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:44.904
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:46.264
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:46.264
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:46.265
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.007
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:49.008
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:49.008
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.012
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.012
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.012
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.016
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.016
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.016
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.020
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.020
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.020
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.023
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.023
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.024
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.029
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.030
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.030
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.033
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.033
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.033
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.036
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.037
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.037
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.039
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.040
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.040
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.043
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.043
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.043
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.046
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.046
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.046
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.049
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.049
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.050
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:49.425
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:49.426
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:49.426
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:52.141
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor59.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:52.141
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor59.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:52.142
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor59.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:52.171
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:52.171
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:52.171
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:53.241
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:53.242
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:53.242
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:53.318
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /**CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
