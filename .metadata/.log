!SESSION 2023-03-13 18:30:31.104 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.bak_0.log
Created Time: 2023-03-13 19:43:53.318

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:53.319
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:53.319
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:54.569
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:43:54.570
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:43:54.570
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:54.622
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:54.623
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:54.623
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:43:55.825
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:43:55.825
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:43:55.826
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:22.590
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:22.590
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:22.591
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:32.525
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:32.526
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:32.526
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:33.348
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:48:33.349
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:48:33.349
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:33.395
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:33.395
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:33.396
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:35.364
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void 
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:48:35.364
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:48:35.365
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:35.487
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void 
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:35.487
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:35.487
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:36.900
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void System.out.println("Done QUERY, support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:48:36.901
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:48:36.901
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:37.095
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void System.out.println("Done QUERY, support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:37.095
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:37.096
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:37.952
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void 
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:48:37.952
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:48:37.953
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:38.283
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void 
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:38.283
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:38.283
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:39.804
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void Report
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:48:39.805
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:48:39.805
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:39.864
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void Report
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:39.864
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:39.864
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:41.611
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:48:41.612
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:48:41.612
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:41.699
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:41.699
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:41.700
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:43.068
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("Done QUERY, support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:48:43.069
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:48:43.069
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:43.138
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("Done QUERY, support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:43.138
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:43.138
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:45.424
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("Done QUERY, support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:45.424
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:45.424
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:47.573
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("Done QUERY, support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:47.574
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:47.574
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:48.411
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("Done QUERY, support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:48.411
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:48.411
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:48.988
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:48:48.989
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:48:48.989
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:48:49.047
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:48:49.047
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:48:49.048
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:49:01.528
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:49:01.528
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:49:01.529
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:49:03.910
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:49:03.911
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:49:03.911
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:49:06.361
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:49:06.361
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:49:06.361
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:49:07.941
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:49:07.941
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:49:07.943
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:49:09.630
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:49:09.630
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:49:09.630
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:49:58.237
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:49:58.237
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:49:58.238
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:00.539
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:00.539
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:00.539
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:15.487
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:15.487
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:15.487
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:15.492
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:15.493
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:15.493
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:19.172
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:19.173
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:19.173
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:34.072
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:34.072
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:34.073
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:44.685
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:44.686
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:44.686
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:47.181
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
	
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:50:47.182
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:50:47.182
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:47.314
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
	
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:47.314
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:47.314
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:49.005
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)

		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:50:49.006
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:50:49.006
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:49.051
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)

		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:49.051
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:49.052
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:50.261
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:50:50.262
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:50:50.262
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:50.290
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:50.290
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:50.290
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:55.339
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport) 
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:55.339
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:55.340
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:56.932
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport)
		   
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:50:56.933
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:50:56.933
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:56.937
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport)
		   
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:56.937
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:56.937
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:57.462
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport)
		  
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:50:57.463
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:50:57.463
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:57.467
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport)
		  
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-13 19:50:57.467
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-13 19:50:57.467
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-13 19:50:59.990
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /**
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /**
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0;
	   if(support+PCASupport > 0)
		   PCAConfidence = float(support)/float(support+PCASupport)
	   
   }
   
   public void ReportPCA()
   {
	   System.out.println("support: " + support + " denominator: " + denominator + " PCA: " + PCAConfidence + " PCA GP: " + PCAConfidenceGP);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	   // Add head to query
	   head = rule.get(0);
	   headStr = head.AtomToString(predicates, variables); 
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString(predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   String query;
	   Atom head;
	   String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar = headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStr = headSub + " " + headPred + " " + headNegObj;
	   // Add head to query
	   query += headStr + ".";
	   
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   String bodyStr = body.AtomToString (predicates, variables);
		   query += " " + bodyStr + ".";
		   
	   }
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-13 19:50:59.991
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-13 19:50:59.991
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.ui.ide 4 4 2023-03-13 23:49:50.525
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:241)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:103)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.getImage(AbstractContributionItem.java:151)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.updateIcons(AbstractContributionItem.java:177)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.update(AbstractContributionItem.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.fill(AbstractContributionItem.java:264)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4785)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:502)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.createWidget(MenuManagerRenderer.java:417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.ui.internal.WorkbenchWindow.setup(WorkbenchWindow.java:858)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:96)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.inject(ContextInjectionFactory.java:83)
	at org.eclipse.ui.internal.Workbench.createWorkbenchWindow(Workbench.java:1468)
	at org.eclipse.ui.internal.Workbench.openWorkbenchWindow(Workbench.java:2461)
	at org.eclipse.ui.internal.Workbench.getWorkbenchPage(Workbench.java:1942)
	at org.eclipse.ui.internal.Workbench.setReference(Workbench.java:1987)
	at org.eclipse.ui.internal.Workbench.lambda$10(Workbench.java:1878)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4785)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl.setContext(PartImpl.java:469)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:634)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1208)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui.ide 4 4 2023-03-13 23:49:50.534
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:241)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:103)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.getImage(AbstractContributionItem.java:151)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.updateIcons(AbstractContributionItem.java:177)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.update(AbstractContributionItem.java:127)
	at org.eclipse.e4.ui.workbench.renderers.swt.AbstractContributionItem.fill(AbstractContributionItem.java:264)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4785)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.createWidget(MenuManagerRenderer.java:417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.hasVisibleMenuItems(StackRenderer.java:1617)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.adjustTopRight(StackRenderer.java:717)
	at org.eclipse.ui.internal.e4.compatibility.ActionBars.forceUpdateTopRight(ActionBars.java:105)
	at org.eclipse.ui.internal.e4.compatibility.ActionBars.updateActionBars(ActionBars.java:85)
	at org.eclipse.ui.part.PageBookView.showPageRec(PageBookView.java:937)
	at org.eclipse.ui.views.contentoutline.ContentOutline.showPageRec(ContentOutline.java:239)
	at org.eclipse.ui.part.PageBookView.createPartControl(PageBookView.java:448)
	at org.eclipse.ui.views.contentoutline.ContentOutline.createPartControl(ContentOutline.java:127)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1208)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1083)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2023-03-16 12:41:42.460 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-16 12:41:43.874
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-16 12:41:49.762
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-16 12:41:53.599
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-16 12:41:53.599
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-16 12:41:53.599
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-16 12:41:55.771
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-03-16 14:32:58.277
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   /** PCA Ratio for the rule 
    *  (support/PCASupport)
    */
   float PCARatio;
   
   /** Support of the head only
    *  
    */
   int headSupport;
   
   /** headCoverage Ratio for the head/rule 
    *  (headSupport/support)
    */
   float headCoverage;
   
   
   
   String headStr;
   String bodyStr;
   String headStrPCA;
   String bodyStrPCA;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /** GetAtomAtIndex
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /** GetBodySize
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** GetHeadStr
    * 
    * @return
    */
   public String GetHeadStr()
   {
	   return headStr;
   }
   
   /** GetBodyStr
    * 
    * @return
    */
   public String GetBodyStr()
   {
	   return bodyStr;
   }
   
   /** GetHeadStrPCA
    * 
    * @return
    */
   public String GetHeadStrPCA()
   {
	   return headStrPCA;
   }
   
   /** GetBodyStrPCA
    * 
    * @return
    */
   public String GetBodyStrPCA()
   {
	   return bodyStrPCA;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   
   /** SetHeadSupport
    *  
    * @param sup
    */
   public void SetHeadSupport(int sup)
   {
	   headSupport = sup;
   }
   
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
	   {
		   PCAConfidence = (float) support/ (float)(support+PCASupport);
	   }
	   if(PCASupport > 0)
	   {
		   PCARatio = (float) support/ (float)(PCASupport);
	   }
		   
	   if(support > 0)
	   {
		   headSupport/u
	   }
	   
   }
   
   /** ReportPCA() 
    * 
    */
   public void ReportPCA()
   {
	   System.out.println("Support Rule:  " + GetHeadStr() + GetBodyStr());
	   System.out.println("PCA Support Rule:  " + GetHeadStrPCA() + GetBodyStrPCA());
	   System.out.println("support: " + support + " PCASupport: " + PCASupport + " PCA: " + PCAConfidence + " PCARatio: " + PCARatio);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   //selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	   
	   bodyStr = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStr += body.AtomToString(predicates, variables) + " . "; 
	   }
	   
	   query += bodyStr;
		 
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   public String BuildHeadQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
       
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	    
	   
	   // Add closing bracket
	   query += "}";
	    
	   return query;
   }
   
   
   
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   
	   String query;
	   Atom head;
	  // String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar =  headSub +  " " + headNegObj + " ";
	   //selectVar =  headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStrPCA = headSub + " " + headPred + " " + headNegObj + ".";
	   // Add head to query
	   query += headStrPCA;
	   
	   bodyStrPCA = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStrPCA += body.AtomToString (predicates, variables)+ " . ";	   
	   }
	   
	   query += bodyStrPCA;
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
   public void RuleReset()
   {
	   headStr= "";
	   bodyStr = "";
	   headStrPCA= "";
	   bodyStrPCA = "";
	   rule.clear();
	   varList.clear();
	   support = 0;
	   PCASupport = 0;
	   PCAConfidence = 0.0f;
	   PCARatio = 0.0f;
   }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-16 14:32:58.278
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-16 14:32:58.279
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-16 14:32:58.358
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   /** PCA Ratio for the rule 
    *  (support/PCASupport)
    */
   float PCARatio;
   
   /** Support of the head only
    *  
    */
   int headSupport;
   
   /** headCoverage Ratio for the head/rule 
    *  (headSupport/support)
    */
   float headCoverage;
   
   
   
   String headStr;
   String bodyStr;
   String headStrPCA;
   String bodyStrPCA;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /** GetAtomAtIndex
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /** GetBodySize
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** GetHeadStr
    * 
    * @return
    */
   public String GetHeadStr()
   {
	   return headStr;
   }
   
   /** GetBodyStr
    * 
    * @return
    */
   public String GetBodyStr()
   {
	   return bodyStr;
   }
   
   /** GetHeadStrPCA
    * 
    * @return
    */
   public String GetHeadStrPCA()
   {
	   return headStrPCA;
   }
   
   /** GetBodyStrPCA
    * 
    * @return
    */
   public String GetBodyStrPCA()
   {
	   return bodyStrPCA;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   
   /** SetHeadSupport
    *  
    * @param sup
    */
   public void SetHeadSupport(int sup)
   {
	   headSupport = sup;
   }
   
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
	   {
		   PCAConfidence = (float) support/ (float)(support+PCASupport);
	   }
	   if(PCASupport > 0)
	   {
		   PCARatio = (float) support/ (float)(PCASupport);
	   }
		   
	   if(support > 0)
	   {
		   headSupport/u
	   }
	   
   }
   
   /** ReportPCA() 
    * 
    */
   public void ReportPCA()
   {
	   System.out.println("Support Rule:  " + GetHeadStr() + GetBodyStr());
	   System.out.println("PCA Support Rule:  " + GetHeadStrPCA() + GetBodyStrPCA());
	   System.out.println("support: " + support + " PCASupport: " + PCASupport + " PCA: " + PCAConfidence + " PCARatio: " + PCARatio);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   //selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	   
	   bodyStr = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStr += body.AtomToString(predicates, variables) + " . "; 
	   }
	   
	   query += bodyStr;
		 
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   public String BuildHeadQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
       
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	    
	   
	   // Add closing bracket
	   query += "}";
	    
	   return query;
   }
   
   
   
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   
	   String query;
	   Atom head;
	  // String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar =  headSub +  " " + headNegObj + " ";
	   //selectVar =  headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStrPCA = headSub + " " + headPred + " " + headNegObj + ".";
	   // Add head to query
	   query += headStrPCA;
	   
	   bodyStrPCA = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStrPCA += body.AtomToString (predicates, variables)+ " . ";	   
	   }
	   
	   query += bodyStrPCA;
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
   public void RuleReset()
   {
	   headStr= "";
	   bodyStr = "";
	   headStrPCA= "";
	   bodyStrPCA = "";
	   rule.clear();
	   varList.clear();
	   support = 0;
	   PCASupport = 0;
	   PCAConfidence = 0.0f;
	   PCARatio = 0.0f;
   }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-16 14:32:58.359
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-16 14:32:58.359
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-16 14:33:01.339
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   /** PCA Ratio for the rule 
    *  (support/PCASupport)
    */
   float PCARatio;
   
   /** Support of the head only
    *  
    */
   int headSupport;
   
   /** headCoverage Ratio for the head/rule 
    *  (headSupport/support)
    */
   float headCoverage;
   
   
   
   String headStr;
   String bodyStr;
   String headStrPCA;
   String bodyStrPCA;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /** GetAtomAtIndex
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /** GetBodySize
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** GetHeadStr
    * 
    * @return
    */
   public String GetHeadStr()
   {
	   return headStr;
   }
   
   /** GetBodyStr
    * 
    * @return
    */
   public String GetBodyStr()
   {
	   return bodyStr;
   }
   
   /** GetHeadStrPCA
    * 
    * @return
    */
   public String GetHeadStrPCA()
   {
	   return headStrPCA;
   }
   
   /** GetBodyStrPCA
    * 
    * @return
    */
   public String GetBodyStrPCA()
   {
	   return bodyStrPCA;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   
   /** SetHeadSupport
    *  
    * @param sup
    */
   public void SetHeadSupport(int sup)
   {
	   headSupport = sup;
   }
   
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
	   {
		   PCAConfidence = (float) support/ (float)(support+PCASupport);
	   }
	   if(PCASupport > 0)
	   {
		   PCARatio = (float) support/ (float)(PCASupport);
	   }
		   
	   if(support > 0)
	   {
		   headSupport/support
	   }
	   
   }
   
   /** ReportPCA() 
    * 
    */
   public void ReportPCA()
   {
	   System.out.println("Support Rule:  " + GetHeadStr() + GetBodyStr());
	   System.out.println("PCA Support Rule:  " + GetHeadStrPCA() + GetBodyStrPCA());
	   System.out.println("support: " + support + " PCASupport: " + PCASupport + " PCA: " + PCAConfidence + " PCARatio: " + PCARatio);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   //selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	   
	   bodyStr = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStr += body.AtomToString(predicates, variables) + " . "; 
	   }
	   
	   query += bodyStr;
		 
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   public String BuildHeadQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
       
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	    
	   
	   // Add closing bracket
	   query += "}";
	    
	   return query;
   }
   
   
   
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   
	   String query;
	   Atom head;
	  // String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar =  headSub +  " " + headNegObj + " ";
	   //selectVar =  headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStrPCA = headSub + " " + headPred + " " + headNegObj + ".";
	   // Add head to query
	   query += headStrPCA;
	   
	   bodyStrPCA = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStrPCA += body.AtomToString (predicates, variables)+ " . ";	   
	   }
	   
	   query += bodyStrPCA;
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
   public void RuleReset()
   {
	   headStr= "";
	   bodyStr = "";
	   headStrPCA= "";
	   bodyStrPCA = "";
	   rule.clear();
	   varList.clear();
	   support = 0;
	   PCASupport = 0;
	   PCAConfidence = 0.0f;
	   PCARatio = 0.0f;
   }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-16 14:33:01.340
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-16 14:33:01.340
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-16 14:33:01.416
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   /** PCA Ratio for the rule 
    *  (support/PCASupport)
    */
   float PCARatio;
   
   /** Support of the head only
    *  
    */
   int headSupport;
   
   /** headCoverage Ratio for the head/rule 
    *  (headSupport/support)
    */
   float headCoverage;
   
   
   
   String headStr;
   String bodyStr;
   String headStrPCA;
   String bodyStrPCA;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /** GetAtomAtIndex
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /** GetBodySize
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** GetHeadStr
    * 
    * @return
    */
   public String GetHeadStr()
   {
	   return headStr;
   }
   
   /** GetBodyStr
    * 
    * @return
    */
   public String GetBodyStr()
   {
	   return bodyStr;
   }
   
   /** GetHeadStrPCA
    * 
    * @return
    */
   public String GetHeadStrPCA()
   {
	   return headStrPCA;
   }
   
   /** GetBodyStrPCA
    * 
    * @return
    */
   public String GetBodyStrPCA()
   {
	   return bodyStrPCA;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   
   /** SetHeadSupport
    *  
    * @param sup
    */
   public void SetHeadSupport(int sup)
   {
	   headSupport = sup;
   }
   
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
	   {
		   PCAConfidence = (float) support/ (float)(support+PCASupport);
	   }
	   if(PCASupport > 0)
	   {
		   PCARatio = (float) support/ (float)(PCASupport);
	   }
		   
	   if(support > 0)
	   {
		   headSupport/support
	   }
	   
   }
   
   /** ReportPCA() 
    * 
    */
   public void ReportPCA()
   {
	   System.out.println("Support Rule:  " + GetHeadStr() + GetBodyStr());
	   System.out.println("PCA Support Rule:  " + GetHeadStrPCA() + GetBodyStrPCA());
	   System.out.println("support: " + support + " PCASupport: " + PCASupport + " PCA: " + PCAConfidence + " PCARatio: " + PCARatio);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   //selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	   
	   bodyStr = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStr += body.AtomToString(predicates, variables) + " . "; 
	   }
	   
	   query += bodyStr;
		 
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   public String BuildHeadQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
       
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	    
	   
	   // Add closing bracket
	   query += "}";
	    
	   return query;
   }
   
   
   
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   
	   String query;
	   Atom head;
	  // String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar =  headSub +  " " + headNegObj + " ";
	   //selectVar =  headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStrPCA = headSub + " " + headPred + " " + headNegObj + ".";
	   // Add head to query
	   query += headStrPCA;
	   
	   bodyStrPCA = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStrPCA += body.AtomToString (predicates, variables)+ " . ";	   
	   }
	   
	   query += bodyStrPCA;
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
   public void RuleReset()
   {
	   headStr= "";
	   bodyStr = "";
	   headStrPCA= "";
	   bodyStrPCA = "";
	   rule.clear();
	   varList.clear();
	   support = 0;
	   PCASupport = 0;
	   PCAConfidence = 0.0f;
	   PCARatio = 0.0f;
   }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-16 14:33:01.417
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-16 14:33:01.417
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-16 14:33:03.912
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   /** PCA Ratio for the rule 
    *  (support/PCASupport)
    */
   float PCARatio;
   
   /** Support of the head only
    *  
    */
   int headSupport;
   
   /** headCoverage Ratio for the head/rule 
    *  (headSupport/support)
    */
   float headCoverage;
   
   
   
   String headStr;
   String bodyStr;
   String headStrPCA;
   String bodyStrPCA;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /** GetAtomAtIndex
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /** GetBodySize
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** GetHeadStr
    * 
    * @return
    */
   public String GetHeadStr()
   {
	   return headStr;
   }
   
   /** GetBodyStr
    * 
    * @return
    */
   public String GetBodyStr()
   {
	   return bodyStr;
   }
   
   /** GetHeadStrPCA
    * 
    * @return
    */
   public String GetHeadStrPCA()
   {
	   return headStrPCA;
   }
   
   /** GetBodyStrPCA
    * 
    * @return
    */
   public String GetBodyStrPCA()
   {
	   return bodyStrPCA;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   
   /** SetHeadSupport
    *  
    * @param sup
    */
   public void SetHeadSupport(int sup)
   {
	   headSupport = sup;
   }
   
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
	   {
		   PCAConfidence = (float) support/ (float)(support+PCASupport);
	   }
	   if(PCASupport > 0)
	   {
		   PCARatio = (float) support/ (float)(PCASupport);
	   }
		   
	   if(support > 0)
	   {
		   headSupport/support
	   }
	   
   }
   
   /** ReportPCA() 
    * 
    */
   public void ReportPCA()
   {
	   System.out.println("Support Rule:  " + GetHeadStr() + GetBodyStr());
	   System.out.println("PCA Support Rule:  " + GetHeadStrPCA() + GetBodyStrPCA());
	   System.out.println("support: " + support + " PCASupport: " + PCASupport + " PCA: " + PCAConfidence + " PCARatio: " + PCARatio);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   //selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	   
	   bodyStr = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStr += body.AtomToString(predicates, variables) + " . "; 
	   }
	   
	   query += bodyStr;
		 
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   public String BuildHeadQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
       
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	    
	   
	   // Add closing bracket
	   query += "}";
	    
	   return query;
   }
   
   
   
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   
	   String query;
	   Atom head;
	  // String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar =  headSub +  " " + headNegObj + " ";
	   //selectVar =  headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStrPCA = headSub + " " + headPred + " " + headNegObj + ".";
	   // Add head to query
	   query += headStrPCA;
	   
	   bodyStrPCA = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStrPCA += body.AtomToString (predicates, variables)+ " . ";	   
	   }
	   
	   query += bodyStrPCA;
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
   public void RuleReset()
   {
	   headStr= "";
	   bodyStr = "";
	   headStrPCA= "";
	   bodyStrPCA = "";
	   rule.clear();
	   varList.clear();
	   support = 0;
	   PCASupport = 0;
	   PCAConfidence = 0.0f;
	   PCARatio = 0.0f;
   }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-16 14:33:03.912
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-16 14:33:03.913
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-16 14:33:04.567
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   /** PCA Ratio for the rule 
    *  (support/PCASupport)
    */
   float PCARatio;
   
   /** Support of the head only
    *  
    */
   int headSupport;
   
   /** headCoverage Ratio for the head/rule 
    *  (headSupport/support)
    */
   float headCoverage;
   
   
   
   String headStr;
   String bodyStr;
   String headStrPCA;
   String bodyStrPCA;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /** GetAtomAtIndex
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /** GetBodySize
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** GetHeadStr
    * 
    * @return
    */
   public String GetHeadStr()
   {
	   return headStr;
   }
   
   /** GetBodyStr
    * 
    * @return
    */
   public String GetBodyStr()
   {
	   return bodyStr;
   }
   
   /** GetHeadStrPCA
    * 
    * @return
    */
   public String GetHeadStrPCA()
   {
	   return headStrPCA;
   }
   
   /** GetBodyStrPCA
    * 
    * @return
    */
   public String GetBodyStrPCA()
   {
	   return bodyStrPCA;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   
   /** SetHeadSupport
    *  
    * @param sup
    */
   public void SetHeadSupport(int sup)
   {
	   headSupport = sup;
   }
   
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
	   {
		   PCAConfidence = (float) support/ (float)(support+PCASupport);
	   }
	   if(PCASupport > 0)
	   {
		   PCARatio = (float) support/ (float)(PCASupport);
	   }
		   
	   if(support > 0)
	   {
		   headSupport/support
	   }
	   
   }
   
   /** ReportPCA() 
    * 
    */
   public void ReportPCA()
   {
	   System.out.println("Support Rule:  " + GetHeadStr() + GetBodyStr());
	   System.out.println("PCA Support Rule:  " + GetHeadStrPCA() + GetBodyStrPCA());
	   System.out.println("support: " + support + " PCASupport: " + PCASupport + " PCA: " + PCAConfidence + " PCARatio: " + PCARatio);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   //selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	   
	   bodyStr = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStr += body.AtomToString(predicates, variables) + " . "; 
	   }
	   
	   query += bodyStr;
		 
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   public String BuildHeadQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
       
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	    
	   
	   // Add closing bracket
	   query += "}";
	    
	   return query;
   }
   
   
   
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   
	   String query;
	   Atom head;
	  // String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar =  headSub +  " " + headNegObj + " ";
	   //selectVar =  headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStrPCA = headSub + " " + headPred + " " + headNegObj + ".";
	   // Add head to query
	   query += headStrPCA;
	   
	   bodyStrPCA = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStrPCA += body.AtomToString (predicates, variables)+ " . ";	   
	   }
	   
	   query += bodyStrPCA;
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
   public void RuleReset()
   {
	   headStr= "";
	   bodyStr = "";
	   headStrPCA= "";
	   bodyStrPCA = "";
	   rule.clear();
	   varList.clear();
	   support = 0;
	   PCASupport = 0;
	   PCAConfidence = 0.0f;
	   PCARatio = 0.0f;
   }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-16 14:33:04.567
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-16 14:33:04.567
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-16 14:33:05.996
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   /** PCA Ratio for the rule 
    *  (support/PCASupport)
    */
   float PCARatio;
   
   /** Support of the head only
    *  
    */
   int headSupport;
   
   /** headCoverage Ratio for the head/rule 
    *  (headSupport/support)
    */
   float headCoverage;
   
   
   
   String headStr;
   String bodyStr;
   String headStrPCA;
   String bodyStrPCA;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /** GetAtomAtIndex
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /** GetBodySize
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** GetHeadStr
    * 
    * @return
    */
   public String GetHeadStr()
   {
	   return headStr;
   }
   
   /** GetBodyStr
    * 
    * @return
    */
   public String GetBodyStr()
   {
	   return bodyStr;
   }
   
   /** GetHeadStrPCA
    * 
    * @return
    */
   public String GetHeadStrPCA()
   {
	   return headStrPCA;
   }
   
   /** GetBodyStrPCA
    * 
    * @return
    */
   public String GetBodyStrPCA()
   {
	   return bodyStrPCA;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   
   /** SetHeadSupport
    *  
    * @param sup
    */
   public void SetHeadSupport(int sup)
   {
	   headSupport = sup;
   }
   
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
	   {
		   PCAConfidence = (float) support/ (float)(support+PCASupport);
	   }
	   if(PCASupport > 0)
	   {
		   PCARatio = (float) support/ (float)(PCASupport);
	   }
		   
	   if(support > 0)
	   {
		   headSupport/ support
	   }
	   
   }
   
   /** ReportPCA() 
    * 
    */
   public void ReportPCA()
   {
	   System.out.println("Support Rule:  " + GetHeadStr() + GetBodyStr());
	   System.out.println("PCA Support Rule:  " + GetHeadStrPCA() + GetBodyStrPCA());
	   System.out.println("support: " + support + " PCASupport: " + PCASupport + " PCA: " + PCAConfidence + " PCARatio: " + PCARatio);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   //selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	   
	   bodyStr = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStr += body.AtomToString(predicates, variables) + " . "; 
	   }
	   
	   query += bodyStr;
		 
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   public String BuildHeadQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
       
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	    
	   
	   // Add closing bracket
	   query += "}";
	    
	   return query;
   }
   
   
   
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   
	   String query;
	   Atom head;
	  // String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar =  headSub +  " " + headNegObj + " ";
	   //selectVar =  headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStrPCA = headSub + " " + headPred + " " + headNegObj + ".";
	   // Add head to query
	   query += headStrPCA;
	   
	   bodyStrPCA = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStrPCA += body.AtomToString (predicates, variables)+ " . ";	   
	   }
	   
	   query += bodyStrPCA;
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
   public void RuleReset()
   {
	   headStr= "";
	   bodyStr = "";
	   headStrPCA= "";
	   bodyStrPCA = "";
	   rule.clear();
	   varList.clear();
	   support = 0;
	   PCASupport = 0;
	   PCAConfidence = 0.0f;
	   PCARatio = 0.0f;
   }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-16 14:33:05.996
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-16 14:33:05.997
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-16 14:33:06.108
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   /** PCA Ratio for the rule 
    *  (support/PCASupport)
    */
   float PCARatio;
   
   /** Support of the head only
    *  
    */
   int headSupport;
   
   /** headCoverage Ratio for the head/rule 
    *  (headSupport/support)
    */
   float headCoverage;
   
   
   
   String headStr;
   String bodyStr;
   String headStrPCA;
   String bodyStrPCA;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /** GetAtomAtIndex
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /** GetBodySize
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** GetHeadStr
    * 
    * @return
    */
   public String GetHeadStr()
   {
	   return headStr;
   }
   
   /** GetBodyStr
    * 
    * @return
    */
   public String GetBodyStr()
   {
	   return bodyStr;
   }
   
   /** GetHeadStrPCA
    * 
    * @return
    */
   public String GetHeadStrPCA()
   {
	   return headStrPCA;
   }
   
   /** GetBodyStrPCA
    * 
    * @return
    */
   public String GetBodyStrPCA()
   {
	   return bodyStrPCA;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   
   /** SetHeadSupport
    *  
    * @param sup
    */
   public void SetHeadSupport(int sup)
   {
	   headSupport = sup;
   }
   
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
	   {
		   PCAConfidence = (float) support/ (float)(support+PCASupport);
	   }
	   if(PCASupport > 0)
	   {
		   PCARatio = (float) support/ (float)(PCASupport);
	   }
		   
	   if(support > 0)
	   {
		   headSupport/ support
	   }
	   
   }
   
   /** ReportPCA() 
    * 
    */
   public void ReportPCA()
   {
	   System.out.println("Support Rule:  " + GetHeadStr() + GetBodyStr());
	   System.out.println("PCA Support Rule:  " + GetHeadStrPCA() + GetBodyStrPCA());
	   System.out.println("support: " + support + " PCASupport: " + PCASupport + " PCA: " + PCAConfidence + " PCARatio: " + PCARatio);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   //selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	   
	   bodyStr = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStr += body.AtomToString(predicates, variables) + " . "; 
	   }
	   
	   query += bodyStr;
		 
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   public String BuildHeadQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
       
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	    
	   
	   // Add closing bracket
	   query += "}";
	    
	   return query;
   }
   
   
   
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   
	   String query;
	   Atom head;
	  // String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar =  headSub +  " " + headNegObj + " ";
	   //selectVar =  headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStrPCA = headSub + " " + headPred + " " + headNegObj + ".";
	   // Add head to query
	   query += headStrPCA;
	   
	   bodyStrPCA = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStrPCA += body.AtomToString (predicates, variables)+ " . ";	   
	   }
	   
	   query += bodyStrPCA;
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
   public void RuleReset()
   {
	   headStr= "";
	   bodyStr = "";
	   headStrPCA= "";
	   bodyStrPCA = "";
	   rule.clear();
	   varList.clear();
	   support = 0;
	   PCASupport = 0;
	   PCAConfidence = 0.0f;
	   PCARatio = 0.0f;
   }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-16 14:33:06.109
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-16 14:33:06.109
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-16 14:33:18.260
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   /** PCA Ratio for the rule 
    *  (support/PCASupport)
    */
   float PCARatio;
   
   /** Support of the head only
    *  
    */
   int headSupport;
   
   /** headCoverage Ratio for the head/rule 
    *  (headSupport/support)
    */
   float headCoverage;
   
   
   
   String headStr;
   String bodyStr;
   String headStrPCA;
   String bodyStrPCA;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /** GetAtomAtIndex
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /** GetBodySize
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** GetHeadStr
    * 
    * @return
    */
   public String GetHeadStr()
   {
	   return headStr;
   }
   
   /** GetBodyStr
    * 
    * @return
    */
   public String GetBodyStr()
   {
	   return bodyStr;
   }
   
   /** GetHeadStrPCA
    * 
    * @return
    */
   public String GetHeadStrPCA()
   {
	   return headStrPCA;
   }
   
   /** GetBodyStrPCA
    * 
    * @return
    */
   public String GetBodyStrPCA()
   {
	   return bodyStrPCA;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   
   /** SetHeadSupport
    *  
    * @param sup
    */
   public void SetHeadSupport(int sup)
   {
	   headSupport = sup;
   }
   
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
	   {
		   PCAConfidence = (float) support/ (float)(support+PCASupport);
	   }
	   if(PCASupport > 0)
	   {
		   PCARatio = (float) support/ (float)(PCASupport);
	   }
		   
	   if(support > 0)
	   {
		    headCoverage float)headSupport/ (float)support
	   }
	   
   }
   
   /** ReportPCA() 
    * 
    */
   public void ReportPCA()
   {
	   System.out.println("Support Rule:  " + GetHeadStr() + GetBodyStr());
	   System.out.println("PCA Support Rule:  " + GetHeadStrPCA() + GetBodyStrPCA());
	   System.out.println("support: " + support + " PCASupport: " + PCASupport + " PCA: " + PCAConfidence + " PCARatio: " + PCARatio);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   //selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	   
	   bodyStr = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStr += body.AtomToString(predicates, variables) + " . "; 
	   }
	   
	   query += bodyStr;
		 
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   public String BuildHeadQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
       
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	    
	   
	   // Add closing bracket
	   query += "}";
	    
	   return query;
   }
   
   
   
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   
	   String query;
	   Atom head;
	  // String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar =  headSub +  " " + headNegObj + " ";
	   //selectVar =  headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStrPCA = headSub + " " + headPred + " " + headNegObj + ".";
	   // Add head to query
	   query += headStrPCA;
	   
	   bodyStrPCA = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStrPCA += body.AtomToString (predicates, variables)+ " . ";	   
	   }
	   
	   query += bodyStrPCA;
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
   public void RuleReset()
   {
	   headStr= "";
	   bodyStr = "";
	   headStrPCA= "";
	   bodyStrPCA = "";
	   rule.clear();
	   varList.clear();
	   support = 0;
	   PCASupport = 0;
	   PCAConfidence = 0.0f;
	   PCARatio = 0.0f;
   }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-16 14:33:18.260
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-16 14:33:18.261
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-16 14:33:18.354
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package main;
import java.util.ArrayList;
import java.util.List;


/**
 * A class that represents rules as a list of binary atoms
 * Each atom is a triple (s,p,o). This first atom in the list
 * is the head atom, all remaining atoms are body atoms of the rule.  
 *
 */

public class GPRule {

   /**
    * Rule containing list of binary atoms  (first item in head atom)
    */
   List<Atom> rule;	
   
   
   /**
    * Stores a unique set of variables used in the rule 
    */
   List<Integer> varList;

   /** Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y) )
    */
   int support;
   
   /** PCA Support of the Rule 
    *  (e.g: (?x :p ?y) => (?x :p2 ?y1) )  
    */
   int PCASupport;
   
   /** Confidence for the rule (Fitness measure for GP)
    *  
    */
   float PCAConfidence;
   
   /** PCA Ratio for the rule 
    *  (support/PCASupport)
    */
   float PCARatio;
   
   /** Support of the head only
    *  
    */
   int headSupport;
   
   /** headCoverage Ratio for the head/rule 
    *  (headSupport/support)
    */
   float headCoverage;
   
   
   
   String headStr;
   String bodyStr;
   String headStrPCA;
   String bodyStrPCA;
   
   
   /**
    * Prefix string for start of a query.
    */
   String queryPrefixSelect =  "PREFIX pf: <http://jena.hpl.hp.com/ARQ/property#>" + 
			    "PREFIX foaf: <http://xmlns.com/foaf/0.1/>" +
			    "PREFIX :<http://yago-knowledge.org/resource/>" +
			    "PREFIX dbp: <http://dbpedia.org/ontology/>" +
			    "PREFIX owl: <http://www.w3.org/2002/07/owl#>" +
			    "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
			    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
			    "PREFIX skos: <http://www.w3.org/2004/02/skos/core#>" +
			    "PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>" +
			    "SELECT DISTINCT ";
   
   
   /**
    * Init GPRule
    */
   public GPRule() {
	 rule = new ArrayList<Atom>();
	 varList = new ArrayList<Integer>();
   }

   /**
    * Adds atom to front of rule
    */
   public void AddAtomToFront(int s, int p, int o)
   {
	   Atom atom = new Atom(s, p, o);
	   rule.add(0,atom);
	   // When new atoms are added to the list, add variables to varlist (only once)
	   if(!varList.contains(s))
	   {
		   varList.add(s);
	   }
	   if(!varList.contains(o))
	   {
		   varList.add(o);
	   }
		   
   }
   
   /** PCA Confidence
    * 
    * @return PCA Confidence
    */
   public float GetPCAConfidence()
   {
	   return PCAConfidence;
   }
   
   /** GetSupport
    * 
    * @return support of rule
    */
   public float GetSupport()
   {
	   return support;
   }
   
   /** GetPCASupport
    * 
    * @return PCAsupport of rule
    */
   public float GetPCASupport()
   {
	   return PCASupport;
   }
     
   /** GetAtomAtIndex
    * Returns atom at given index
    */
   public Atom GetAtomAtIndex(int index)
   {
	   return rule.get(index);
   }
   
   /** GetBodySize
    * Returns body size (assumes at least one atom (head) is in the rule list).
    */
   public int GetBodySize()
   {
	   int bodySize = rule.size() - 1;
	   return bodySize;
   }
   
   /** GetHeadStr
    * 
    * @return
    */
   public String GetHeadStr()
   {
	   return headStr;
   }
   
   /** GetBodyStr
    * 
    * @return
    */
   public String GetBodyStr()
   {
	   return bodyStr;
   }
   
   /** GetHeadStrPCA
    * 
    * @return
    */
   public String GetHeadStrPCA()
   {
	   return headStrPCA;
   }
   
   /** GetBodyStrPCA
    * 
    * @return
    */
   public String GetBodyStrPCA()
   {
	   return bodyStrPCA;
   }
   
   /** SetSupport
    *  
    * @param sup
    */
   public void SetSupport(int sup)
   {
	   support = sup;
   }
   
   
   /** SetHeadSupport
    *  
    * @param sup
    */
   public void SetHeadSupport(int sup)
   {
	   headSupport = sup;
   }
   
   
   /** Set PCASupport
    * 
    * @param sup
    */
   public void SetPCASupport(int sup)
   {
	   PCASupport = sup;
   }
   
   /** CalculatePCA()
    * 
    */
   public void CalculatePCA()
   {
	   PCAConfidence = 0.0f;
	   if(support+PCASupport > 0)
	   {
		   PCAConfidence = (float) support/ (float)(support+PCASupport);
	   }
	   if(PCASupport > 0)
	   {
		   PCARatio = (float) support/ (float)(PCASupport);
	   }
		   
	   if(support > 0)
	   {
		    headCoverage float)headSupport/ (float)support
	   }
	   
   }
   
   /** ReportPCA() 
    * 
    */
   public void ReportPCA()
   {
	   System.out.println("Support Rule:  " + GetHeadStr() + GetBodyStr());
	   System.out.println("PCA Support Rule:  " + GetHeadStrPCA() + GetBodyStrPCA());
	   System.out.println("support: " + support + " PCASupport: " + PCASupport + " PCA: " + PCAConfidence + " PCARatio: " + PCARatio);
   }
   
   /**
    * Builds query string to test support of the rule.
    */
   public String BuildRuleSupportQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   //selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	   
	   bodyStr = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStr += body.AtomToString(predicates, variables) + " . "; 
	   }
	   
	   query += bodyStr;
		 
	   
	   // Add closing bracket
	   query += "}";
	   
	 //  "SELECT DISTINCT ?a ?b  WHERE { " +
	 //  " {?a :isMarriedTo  ?b .} " +     
	//   " {?b :isMarriedTo  ?a .} " +  
	//   "}";	
	   
	   return query;
   }
   
   public String BuildHeadQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   String query;
	   Atom head;				  
	   String selectVar =" ";				  // Contains variables for SELECT
	   
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   
	   // Get head
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
       
	   selectVar =  headSub +  " " + headObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	   
	 
	  
	   headStr = head.AtomToString(predicates, variables) + " . "; 
	   query += headStr;
	    
	   
	   // Add closing bracket
	   query += "}";
	    
	   return query;
   }
   
   
   
   
   /**
    * Builds query string to test negative support of the rule.
    */
   public String BuildRuleNegativeQueryString(String[] predicates, String[] variables)
   {
	   if(rule.size() == 0 ) return " ";
	   
	   
	   String query;
	   Atom head;
	  // String headStr;					  
	   String selectVar =" ";				  	// Contains variables for SELECT
	
	   // Used to store head variables and predicates for negation
	   String headSub;
	   String headPred;
	   String headObj; 
	   String headNegObj;						
	   int subIdx;
	   int predIdx;
	   int objIdx;
	   
	   // Add prefix to query
	   query = queryPrefixSelect;
	   
	   // Get head atom
	   head = rule.get(0);
	   
	   // Look up indices
	   subIdx  = head.GetSIdx();
	   predIdx = head.GetPIdx();
	   objIdx  = head.GetOIdx();;
	   
	   
	   // Find each s,p,o using atom indices
	   headSub = "?" + variables[subIdx];
	   headPred = ":" + predicates[predIdx];
	   headObj = "?" + variables[objIdx];
	   
	   // Create a negation variable for PCA
	   headNegObj = headObj +"_1";
	   
       // Get Variables for select  	
	   for(int i= 0; i < varList.size(); i++)
	   {
		   
		   selectVar += "?" + variables[varList.get(i)] + " ";
	   }
	   
	   // Add the negation variable to the select 
	   selectVar =  headSub +  " " + headNegObj + " ";
	   //selectVar =  headNegObj + " ";
	   
	   selectVar +=  "WHERE { ";
	   
	   // Add variables and where clause to query
	   query += selectVar;
	  
	   // Build head string for query
	   headStrPCA = headSub + " " + headPred + " " + headNegObj + ".";
	   // Add head to query
	   query += headStrPCA;
	   
	   bodyStrPCA = " ";
	   // Add Body or Bodies to query
	   for(int i = 1; i < rule.size(); i++ )
	   {
		   Atom body = rule.get(i);
		   bodyStrPCA += body.AtomToString (predicates, variables)+ " . ";	   
	   }
	   
	   query += bodyStrPCA;
	   
	   query += " FILTER(" + headObj +  " != " + headNegObj + ")";
	   
	   // Add closing bracket
	   query += "}";
	   
	 //?b <isMarriedTo> ?a => ?a <isMarriedTo> ?b	    QUESTION ASK 
	 //"SELECT DISTINCT ?b1    WHERE { " +
	 //" {?a :isMarriedTo  ?b1 .} " +     
	 //" {?b :isMarriedTo  ?a .} " +  
	 //" FILTER (?b1 !=  ?b) " +
	 //"}";
	   
	   return query;
   }
   
   public void RuleReset()
   {
	   headStr= "";
	   bodyStr = "";
	   headStrPCA= "";
	   bodyStrPCA = "";
	   rule.clear();
	   varList.clear();
	   support = 0;
	   PCASupport = 0;
	   PCAConfidence = 0.0f;
	   PCARatio = 0.0f;
   }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-16 14:33:18.355
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-16 14:33:18.355
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui.ide 4 4 2023-03-16 14:52:50.913
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:241)
	at org.eclipse.jface.resource.DeferredImageDescriptor.createImage(DeferredImageDescriptor.java:85)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:97)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.ui.actions.OpenWithMenu.getImage(OpenWithMenu.java:137)
	at org.eclipse.ui.actions.OpenWithMenu.createMenuItem(OpenWithMenu.java:174)
	at org.eclipse.ui.actions.OpenWithMenu.fill(OpenWithMenu.java:271)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4785)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:294)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:304)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1076)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1014)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:379)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2284)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4095)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3636)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2023-03-16 15:27:47.235 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-16 15:27:47.790
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-16 15:27:50.699
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-16 15:27:51.651
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-16 15:27:51.651
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-16 15:27:51.651
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-16 15:27:53.399
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-17 08:15:29.326 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-17 08:15:29.940
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-17 08:15:34.225
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-17 08:15:35.305
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-17 08:15:35.305
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-17 08:15:35.306
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-17 08:15:37.264
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-17 18:42:42.218 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-17 18:42:43.676
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-17 18:42:47.885
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-17 18:42:51.574
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-17 18:42:51.574
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-17 18:42:51.574
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-17 18:42:53.618
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-18 07:23:07.870 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-18 07:23:09.234
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-18 07:23:13.289
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-18 07:23:16.911
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-18 07:23:16.911
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-18 07:23:16.911
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-18 07:23:18.976
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.debug.ui 4 150 2023-03-18 18:05:50.994
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1378)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1013)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.updateVariables(JDIStackFrame.java:729)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables0(JDIStackFrame.java:395)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables(JDIStackFrame.java:307)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.containsVariable(JavaDebugHover.java:620)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$2(JavaDebugHover.java:639)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:469)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.IllegalStateException
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1381)
	... 12 more
!SUBENTRY 1 org.eclipse.jdt.debug 4 100 2023-03-18 18:05:50.994
!MESSAGE Invalid stack frame
!STACK 0
java.lang.IllegalStateException
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1381)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1013)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.updateVariables(JDIStackFrame.java:729)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables0(JDIStackFrame.java:395)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables(JDIStackFrame.java:307)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.containsVariable(JavaDebugHover.java:620)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$2(JavaDebugHover.java:639)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:469)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug.ui 4 150 2023-03-18 18:06:45.289
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1378)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1013)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.updateVariables(JDIStackFrame.java:729)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables0(JDIStackFrame.java:395)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables(JDIStackFrame.java:307)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.containsVariable(JavaDebugHover.java:620)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$2(JavaDebugHover.java:639)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:469)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
Caused by: java.lang.IllegalStateException
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1381)
	... 12 more
!SUBENTRY 1 org.eclipse.jdt.debug 4 100 2023-03-18 18:06:45.289
!MESSAGE Invalid stack frame
!STACK 0
java.lang.IllegalStateException
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1381)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1013)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.updateVariables(JDIStackFrame.java:729)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables0(JDIStackFrame.java:395)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables(JDIStackFrame.java:307)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.containsVariable(JavaDebugHover.java:620)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$2(JavaDebugHover.java:639)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:469)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2023-03-19 21:28:00.887 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-19 21:28:02.261
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-19 21:28:11.187
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-19 21:28:14.719
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-19 21:28:14.719
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-19 21:28:14.719
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-19 21:28:16.721
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-21 13:08:17.908 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-21 13:08:19.236
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-21 13:08:22.639
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-21 13:08:26.358
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-21 13:08:26.358
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-21 13:08:26.359
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-21 13:08:28.651
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-21 14:32:05.588 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-21 14:32:06.158
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-21 14:32:10.369
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-21 14:32:11.310
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-21 14:32:11.311
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-21 14:32:11.311
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-21 14:32:13.131
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-21 15:38:18.849 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-21 15:38:19.429
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-21 15:38:25.614
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-21 15:38:26.546
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-21 15:38:26.546
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-21 15:38:26.546
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-21 15:38:28.300
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2023-03-23 00:00:41.229
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:241)
	at org.eclipse.jface.resource.DeferredImageDescriptor.createImage(DeferredImageDescriptor.java:85)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:97)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.ui.actions.OpenWithMenu.getImage(OpenWithMenu.java:137)
	at org.eclipse.ui.actions.OpenWithMenu.createMenuItem(OpenWithMenu.java:174)
	at org.eclipse.ui.actions.OpenWithMenu.fill(OpenWithMenu.java:271)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4785)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:294)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:304)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1076)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1014)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:379)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2284)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4095)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3636)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2023-03-23 08:02:51.068 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-23 08:02:52.467
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-23 08:05:02.581
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-23 08:05:06.403
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-23 08:05:06.403
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-23 08:05:06.403
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-23 08:05:07.813
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2023-03-23 12:42:56.241
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:241)
	at org.eclipse.jface.resource.DeferredImageDescriptor.createImage(DeferredImageDescriptor.java:85)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:97)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.ui.actions.OpenWithMenu.getImage(OpenWithMenu.java:137)
	at org.eclipse.ui.actions.OpenWithMenu.createMenuItem(OpenWithMenu.java:174)
	at org.eclipse.ui.actions.OpenWithMenu.fill(OpenWithMenu.java:271)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor21.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4785)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:294)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:304)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1076)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1014)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:379)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2284)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4095)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3636)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2023-03-23 12:54:14.238 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-23 12:54:15.661
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-23 12:54:19.612
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-23 12:54:23.384
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-23 12:54:23.384
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-23 12:54:23.384
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-23 12:54:25.293
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-24 08:17:42.352 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-24 08:17:42.925
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-24 08:18:03.474
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-24 08:18:04.596
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-24 08:18:04.596
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-24 08:18:04.596
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-24 08:18:05.886
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui.ide 4 4 2023-03-26 21:46:46.759
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:668)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:241)
	at org.eclipse.jface.resource.DeferredImageDescriptor.createImage(DeferredImageDescriptor.java:85)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:230)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.LazyResourceManager.create(LazyResourceManager.java:97)
	at org.eclipse.jface.resource.LocalResourceManager.allocate(LocalResourceManager.java:72)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImage(ResourceManager.java:175)
	at org.eclipse.ui.actions.OpenWithMenu.getImage(OpenWithMenu.java:137)
	at org.eclipse.ui.actions.OpenWithMenu.createMenuItem(OpenWithMenu.java:174)
	at org.eclipse.ui.actions.OpenWithMenu.fill(OpenWithMenu.java:271)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4785)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:294)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:304)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1076)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.reconcileManagerToModel(MenuManagerRenderer.java:1014)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:379)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4256)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2284)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4095)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3636)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2023-03-26 21:47:06.048 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-26 21:47:07.484
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-26 21:47:10.722
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-26 21:47:14.599
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-26 21:47:14.599
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-26 21:47:14.599
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-26 21:47:16.562
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-27 18:34:06.224 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-27 18:34:07.596
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-27 18:34:13.505
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-27 18:34:17.138
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-27 18:34:17.138
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-27 18:34:17.138
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-27 18:34:19.060
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-30 20:41:15.547 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.6
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY ch.qos.logback.classic 1 0 2023-03-30 20:41:16.941
!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.

!ENTRY ch.qos.logback.classic 1 0 2023-03-30 20:41:25.720
!MESSAGE Logback config file: C:\Users\Gina Grossi\eclipse-workspace\GP\RuleDiscoveryProject\.metadata\.plugins\org.eclipse.m2e.logback\logback.2.1.0.20221015-0744.xml

!ENTRY org.eclipse.jface 2 0 2023-03-30 20:41:29.400
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-30 20:41:29.400
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-30 20:41:29.400
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-30 20:41:31.460
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Gina Grossi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
